<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gulp-api之gulp-task]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-task%2F</url>
    <content type="text"><![CDATA[gulp.taskgulp.task方法用来定义任务，内部使用的是Orchestrator(用于排序、执行任务和最大并发依赖关系的模块)，其语法为：1gulp.task(name[, deps], fn) name 为任务名； deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数； fn为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 当你定义一个简单的任务时，需要传入任务名字和执行函数两个属性。123gulp.task(&apos;greet&apos;, function () &#123; console.log(&apos;Hello world!&apos;);&#125;); 执行gulp greet的结果就是在控制台上打印出“Hello world”。 也可以定义一个在gulp开始运行时候默认执行的任务，并将这个任务命名为“default”： 123gulp.task(&apos;default&apos;, function () &#123; // Your default task&#125;); 当有多个任务时，需要知道怎么来控制任务的执行顺序。 可以通过任务依赖来实现。例如我想要执行one,two,three这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：12//只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task(&apos;default&apos;,[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]); 如果任务相互之间没有依赖，任务就会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。但是如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：1234567891011gulp.task(&apos;one&apos;,function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log(&apos;one is done&apos;) &#125;,5000);&#125;); //two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); 上面的例子中我们执行two任务时，会先执行one任务，但不会去等待one任务中的异步操作完成后再执行two任务，而是紧接着执行two任务。所以two任务会在one任务中的异步操作完成之前就执行了。 那如果想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？ 有三种方法可以实现： 1.：在异步操作完成后执行一个回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数。12345678910111213gulp.task(&apos;one&apos;,function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 exec(function()&#123; console.log(&apos;one is finish&apos;); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;); //这时two任务会在one任务中的异步操作完成后再执行gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is finish&apos;);&#125;); 2. ：定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。1234567891011gulp.task(&apos;one&apos;,function(cb)&#123; var stream = gulp.src(&apos;client/**/*.js&apos;) .pipe(exec()) //exec()中有某些异步操作 .pipe(gulp.dest(&apos;build&apos;)); return stream;&#125;); gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); 3. ：返回一个promise对象，例如1234567891011121314var Q = require(&apos;q&apos;);gulp.task(&apos;one&apos;, function() &#123; var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 1); return deferred.promise;&#125;); gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;);]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-api之gulp-watch]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-watch%2F</url>
    <content type="text"><![CDATA[gulp.watch gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为 gulp.watch(glob[, opts], tasks);glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。opts 为一个可选的配置对象，通常不需要用到。tasks 为文件变化后要执行的任务，为一个数组。 1234567gulp.task(&apos;uglify&apos;,function()&#123; //do something&#125;);gulp.task(&apos;reload&apos;,function()&#123; //do something&#125;);gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); gulp.watch()还有另外一种使用方式： gulp.watch(glob[, opts, cb]); glob和opts参数与第一种用法相同; cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径。 1234gulp.watch(&apos;js/**/*.js&apos;, function(event)&#123; console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;);]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-api之gulp-dest]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-dest%2F</url>
    <content type="text"><![CDATA[gulp.destgulp.dest()方法是用来写文件的，其语法为：1gulp.dest(path[,options]) path为写入文件的路径； options为一个可选的参数对象，以下为选项参数： options.cwd类型： String 默认值： process.cwd() 输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。 options.mode类型： String 默认值： 0777 八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。 123var gulp = require(&apos;gulp&apos;);gulp.src(&apos;script/jquery.js&apos;) // 获取流 .pipe(gulp.dest(&apos;dist/foo.js&apos;)); // 写放文件 下面再说说生成的文件路径与我们给gulp.dest()方法传入的路径参数之间的关系。 gulp.dest(path)生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径。例如：1234var gulp = reruire(&apos;gulp&apos;);//有通配符开始出现的那部分路径为 **/*.jsgulp.src(&apos;script/**/*.js&apos;) .pipe(gulp.dest(&apos;dist&apos;)); //最后生成的文件路径为 dist/**/*.js 如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js用gulp.dest()把文件流写入文件后，文件流仍然可以继续使用。]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-api 之gulp.src]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-src%2F</url>
    <content type="text"><![CDATA[gulp.srcgulp.src()方法是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinylfiles)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息。其语法为：1gulp.src(globs[, options]); globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。1gulp.src(&apos;script/jquery.js&apos;) // 获取script文件下的jquery.js 当有多个匹配模式时，该参数可以为一个数组;类型为String或 Array。12// 使用数组的方式来匹配多种文件`gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;]) options.buffer类型： Boolean 默认值：true 如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。注意：插件可能并不会实现对 stream 的支持。 options.read类型： Boolean 默认值：true 如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。 options.base类型： String ， 设置输出路径以某个路径的某个组成部分为基础向后拼接。 如, 请想像一下在一个路径为 client/js/somedir 的目录中，有一个文件叫 somefile.js ：1234567gulp.src(&apos;client/js/**/*.js&apos;) // 匹配 &apos;client/js/somedir/somefile.js&apos; 现在 `base` 的值为 `client/js/` .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); // 写入 &apos;build/somedir/somefile.js&apos; 将`client/js/`替换为build gulp.src(&apos;client/js/**/*.js&apos;, &#123; base: &apos;client&apos; &#125;) // base 的值为 &apos;client&apos; .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); // 写入 &apos;build/js/somedir/somefile.js&apos; 将`client`替换为build]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 入门文档]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[新建 gulpfile.js gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript、coffee、sass、less、html/image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 npm init新建gulpfile.js文件写入 gulp任务 123456789101112131415161718var gulp = require(&apos;gulp&apos;), less = require(&apos;gulp-less&apos;), minifyCSS = require(&apos;gulp-minify-css&apos;);gulp.task(&apos;testLess&apos;, function () &#123; gulp.src(&apos;src/less/index.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;);gulp.task(&apos;css&apos;, function () &#123; gulp.src(&apos;dist/css/*.css&apos;) .pipe(minifyCSS()) .pipe(gulp.dest(&apos;dist/css&apos;))&#125;)gulp.task(&apos;default&apos;,[&apos;css&apos;]); 命令行 gulp 或者gulp css/testLess gulp的使用流程一般是：首先通过gulp.src()方法获取到想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中。例如： *123var gulp = require(&apos;gulp&apos;);gulp.src(&apos;script/jquery.js&apos;) // 获取流的api .pipe(gulp.dest(&apos;dist/foo.js&apos;)); // 写放文件的api]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于javascrip中sort函数的使用]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%85%B3%E4%BA%8Ejavascrip%E4%B8%ADsort%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[需求有个这样的东西，后台接口各个城市的数据，前端根据数据按照首字母进行分类，排序，进行渲染。在W3CSchool中看到，这个函数的一些说明。如下图 原始数据格式如下：12345[ &#123;"Name": "江苏省", "cityList": [...],"Header": "jiangsusheng"&#125;, &#123;"Name": "江西省", "cityList": [...],"Header": "jiangxisheng"&#125;, &#123;"Name": "辽宁省","cityList": [...],"Header": "liaoningsheng"&#125;] 我们只需要将数据格式更换为1234567891011 [ &#123; "name":"A", "city":[ &#123;"Name": "辽宁省","cityList": [...],"Header": "liaoningsheng"&#125;] &#125;, &#123; "name":"J", "city":[ &#123;"Name": "江苏省", "cityList": [...],"Header": "jiangsusheng"&#125;, &#123;"Name": "江西省", "cityList": [...],"Header": "jiangxisheng"&#125; ] &#125;,] 第一步 将数组首字母相同的合并123456789101112131415161718192021function merge(arr) &#123; var res = []; var json = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if (!json[arr[i].name]) &#123; var sJson=&#123;&#125;; sJson.name=arr[i].name; sJson.list=arr[i].list; res.push(sJson); json[arr[i].name] = 1; &#125;else&#123; for(var k=0; k&lt;res.length; k++)&#123; if(arr[i].name==res[k].name)&#123; res[k].list.push(arr[i].list[0]); break; &#125; &#125; &#125; &#125; return res;&#125; 第二步 实现数组按照某个属性排序1234567891011121314151617function rank (prop)&#123; return function (obj1, obj2) &#123; var val1 = obj1[prop]; var val2 = obj2[prop]; if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123; val1 = Number(val1); val2 = Number(val2); &#125; if (val1 &gt; val2) &#123; //升序排列 return 1; &#125; else if (val1 &lt; val2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;;&#125; eg:12345[ &#123;name:'gpp',age:0&#125;, &#123;name:'aop',age:18&#125;, &#123;name:'yjj',age:8&#125; ] 效果123456arr.sort(rank('name'))[ &#123;name:'aop',age:0&#125;, &#123;name:'gpp',age:18&#125;, name:'yjj',age:8&#125; ] 至此，完结.]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 的 Promise 对象]]></title>
    <url>%2F2017%2F08%2F10%2FES6-%E7%9A%84-Promise-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[目录一段使用了promise的基本语句代码123456789101112131415function helloWorld (ready) &#123; return new Promise(function (resolve, reject) &#123; if (ready) &#123; resolve("Hello World!"); &#125; else &#123; reject("Good bye!"); &#125; &#125;);&#125;helloWorld(true).then(function (message) &#123; alert(message);&#125;, function (error) &#123; alert(error);&#125;); 上面的代码实现的功能非常简单~~，helloWord函数接受一个参数，如果为 true 就打印 “Hello World!”，如果为 false 就打印错误的信息。helloWord 函数返回的是一个 ==Promise== 对象。 resolve 和 reject在 Promise 对象当中有两个重要方法————resolve 和 reject。 resolve 方法可以使 Promise对象的状态改变成成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。 reject 方法则是将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。 then 和 catchthen1234567891011121314151617181920212223function printHello(ready)&#123; return new Promise(function(resolve,reject)&#123; if(ready)&#123; resolve("hello") &#125;else&#123; reject("bad") &#125; &#125;)&#125;function printWorld()&#123; alert('world')&#125;function print1()&#123; alert('!')&#125;printHello(true).then(function(message)&#123; alert(message)&#125;).then(printWorld).then(print1) then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象。另外，在 then onFulfilled的函数当中的返回值，可以作为后续操作的参数，因此上面的例子也可以写成 123456789101112131415161718192021function printHello(ready)&#123; return new Promise(function(resolve,reject)&#123; if(ready)&#123; resolve("hello") &#125;else&#123; reject("err") &#125; &#125;)&#125;printHello(true).then(function(message)&#123; return message&#125;).then(function(message)&#123; return message+'world'&#125;).then(function(message)&#123; return message + '!'&#125;).then(function(message)&#123; alert(message)&#125;).catch(function(err)&#123; alert(err)&#125;); catch catch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected函数的一个简单的写法，也就是说可以写成 then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch的写法比一般的写法更加清晰明确。 Promise.all 和 Promise.race Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为resolve 时，该方法才会返回。 123456789101112131415var p1 = new Promise(function (resolve) &#123; setTimeout(function () &#123; resolve("Hello"); &#125;, 3000);&#125;);var p2 = new Promise(function (resolve) &#123; setTimeout(function () &#123; resolve("World"); &#125;, 1000);&#125;);Promise.all([p1, p2]).then(function (result) &#123; console.log(result); // ["Hello", "World"]&#125;); 上面的例子模拟了传输两个数据需要不同的时长，虽然 p2 的速度比 p1 要快，但是 Promise.all 方法会按照数组里面的顺序将结果返回。 日常开发中经常会遇到这样的需求，在不同的接口请求数据然后拼合成自己所需的数据，通常这些接口之间没有关联（例如不需要前一个接口的数据作为后一个接口的参数），这个时候 Promise.all 方法就可以派上用场了。还有一个和 Promise.all 相类似的方法 Promise.race，它同样接收一个数组，不同的是只要该数组中的 Promise 对象的状态发生变化（无论是 resolve 还是 reject）该方法都会返回。 参考JavaScript Promise迷你书（中文版）]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建的blog的流程]]></title>
    <url>%2F2017%2F08%2F08%2F%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%9A%84blog%E7%9A%84%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[按照流程进行如下初始环境配置 本地环境搭建1$ npm install hexo-cli -g 1$ hexo init 1$ npm install 1$ hexo g 1$ hexo s 运行localhost:4000端口即可访问 hexo基本命令： hexo g #完整命令为hexo generate，用于生成静态文件 hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览 hexo d #完整命令为hexo deploy，用于将本地文件发布到github上 hexo n #完整命令为hexo new，用于新建一篇文章 hexo clean 清除缓存 更改默认主题配置下载next (配置了大众化的next) $ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改根目录配置文件theme: next 发布文章每次发布执行以下3步即可 hexo clean hexo generate hexo deploy 新建文章hexo new “xxx”在source目录下找到新建页面修改即可。 #删除文章eg:(helloworld)&nbsp;&nbsp;&nbsp;&nbsp;先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。&nbsp;&nbsp;&nbsp;&nbsp;具体来说，以最开始默认形成的helloworld.md这篇文章为例。首先进入到source / _post 文件夹中，&nbsp;&nbsp;&nbsp;&nbsp;找到helloworld.md文件，在本地直接执行删除。然后依次执行hexo g，hexo d，这就是如何删除文章的方法。 同步远程仓库修改配置修改根目录配置文件_config.yml&nbsp;&nbsp;&nbsp;&nbsp; type: git&nbsp;&nbsp;&nbsp;&nbsp; repository: https://github.com/username/username.github.io.git&nbsp;&nbsp;&nbsp;&nbsp; branch: master hexo deploy 发布* ERROR: &nbsp;&nbsp;&nbsp;Deployer not found : github&nbsp;&nbsp;&nbsp;&nbsp; npm install hexo-deployer-git –save]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
