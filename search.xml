<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[补]jquery 插件开发]]></title>
    <url>%2F2018%2F01%2F23%2F%E8%A1%A5-jquery-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在实际开发工作中，总会碰到像滚动，分页，日历等展示效果的业务需求，对于接触过jQuery以及熟悉jQuery使用的人来说，首先想到的肯定是寻找现有的jQuery插件来满足相应的展示需求。目前页面中常用的一些组件，都有多种jQuery插件可供选择，网络上也有很多专门收集jQuery插件的网站。利用jQuery插件确实可以给我们的开发工作带来便捷，但是如果只是会简单使用，而对其中的原理不甚了解，那么在使用过程中碰到问题或者对插件进行定制开发时就会有诸多疑惑。本文的目的就是可以快速了解jQuery插件的开发原理以及掌握jQuery开发的基本技能。 进行jQuery插件开发前，首先要知道两个问题：什么是jQuery插件？jQuery插件如何使用？ 第一个问题，jQuery插件就是用来扩展jQuery原型对象的一个方法，简单来说就是jQuery插件是jQuery对象的一个方法。其实回答了第一个问题，也就知道第二个问题的答案了，jQuery插件的使用方式就是jQuery对象方法的调用。 我们先看个例子：$(“a”).css(“color”,”red”)。我们知道每个jQuery对象都会包含jQuery中定义的DOM操作方法,这里使用$方法来选择a元素，返回一个a元素的jQuery对象，这个对象就可以使用jQuery中定义的DOM操作方法。那么jQuery对象是如何获取这些方法的呢？其实jQuery内部定义了一个jQuery.fn对象，查看jQuery源码可以发现jQuery.fn=jQuery.prototype，也就是说jQuery.fn对象是jQuery的原型对象,jQuery的DOM操作方法都在jQuery.fn对象上定义的，然后jQuery对象就可以通过原型继承这些方法。 基础版jQuery插件 知道了上面这些知识，我们就可以来写一个简单的jQuery插件。假如我现在需要一个jQuery插件用来改变标签内容颜色，就可以按下面的方式来实现这个插件：123$.fn.changeStyle = function(colorStr)&#123; this.css("color",colorStr);&#125; 然后按照下面这种方式调用:1$("p").changeStyle("red"); 插件调用的时候，插件内部的this就是当前调用插件的jQuery对象，这样的话每个使用$()方法选择的标签，在调用changeStyle()插件时都会使用css()方法重设color样式。 满足链式调用的jQuery插件 链式调用时jQuery的一大特色，一个通用的插件应该遵循jQuery风格，满足链式调用要求。实现链式调用的方式也很简单： 1234$.fn.changeStyle = function(colorStr)&#123; this.css("color",colorStr); return this;&#125; 然后使用的时候就可以链式调用其他方法了：1$("p").changeStyle("red").addClass("red-color"); 防止$符号污染的jQuery插件 有很多js库都会使用$符号，虽然jQuery可以使用jQuery.noConflict()方法交出$符号的使用权，但是如果定义插件的时候，使用$.fn对象来定义的，那么这些插件使用的时候就会受到其它使用$变量的js库的影响。对于这种情况，我们可以使用立即执行函数通过传参的方式封装插件。形式如下：1234567(function($)&#123; $.fn.changeStyle = function(colorStr)&#123; this.css("color",colorStr); return this; &#125;&#125;(jQuery)); 因为使用了立即执行函数，所以此时的$只属于这个立即执行函数的函数作用域，这样就可以避免$符号的污染。 可以接受参数的jQuery插件如果需要传给插件内部的参数比较多，我们可以定义一个参数对象，然后把需要传给插件的参数放在参数对象中。插件定义时如下：1234567(function($)&#123; $.fn.changeStyle = function(option)&#123; this.css("color",option.colorStr).css("fontSize",option.fontSize+"px"); return this; &#125; &#125;(jQuery)); 使用方式：$(“p”).changeStyle({colorStr:”red”,fontSize:14}); 把参数放到一个对象中传给插件还有一个好处就是我们可以在插件内部为一些参数定义一些缺省值，例如： 123456789(function($)&#123; $.fn.changeStyle = function(option)&#123; var defaultSetting = &#123; colorStr:"green",fontSize:12&#125;; var setting = $.extend(defaultSetting,option); this.css("color",setting.colorStr).css("fontSize",setting.fontSize+"px"); return this; &#125;&#125;(jQuery)); 上面的代码用到了$.extend方法，这个方法在这里的用法就是合并两个对象，即把后面一个对象的存在的属性值赋值给第一个对象，具体用法可以参考这里。$.extend方法还有一种作用是用来扩展jQuery对象本身。 这样定义的插件，我们在使用时如果不传fontSize，那么使用这个插件的jQuery对象标签的内容会被设置成默认的12px。 使用方式：$(“p”).changeStyle({colorStr:”red”}); 注意：在为插件定义默认参数时，一定要把默认参数写在插件方法内部，这样默认参数的作用域就在插件内部。 总结 定义插件的方式除了上面说的用$.fn来定义，还有另外一种方式来定义插件，那就是使用$.fn.extend方法。类似下面的写法： 12345678910function($)&#123; $.fn.extend(&#123; changeStyle:function(option)&#123; var defaultSetting = &#123; colorStr:"green",fontSize:12&#125;; var setting = $.extend(defaultSetting,option); this.css("color",setting.colorStr).css("fontSize",setting.fontSize+"px"); return this; &#125; &#125;);&#125;(jQuery)); &gt; PS:$.extend方法和$.fn.extend方法都可以用来扩展jQuery功能，通过阅读jQuery源码我们可以发现这两个方法的本质区别，那就是$.extend方法是在jQuery全局对象上扩展方法，$.fn.extend方法是在$选择符选择的jQuery对象上扩展方法。所以扩展jQuery的公共方法一般用$.extend方法，定义插件一般用$.fn.extend方法。]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>jquery插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用本地存储解决vue开发的刷新后页面空白问题]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E8%A7%A3%E5%86%B3Vue%E5%88%B7%E6%96%B0%E5%90%8E%E9%A1%B5%E9%9D%A2%E7%A9%BA%E7%99%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[用vue开发的单页面应用，为什么不能在内页刷新？ 即使改成hash模式，刷新页面后store里的值还是会丢失啊，所以用了本地存储来解决问题 一 .新建 plugins.js1234567891011121314151617181920212223242526272829303132import &#123; STAGE_MUTATION_USER_OPTIONS, STAGE_MUTATION_SERVER_CONDITIONS_1,&#125; from './mutations'const localStoragePlugin = store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; console.log( 'mutation', mutation, 'state', state ) if( STAGE_MUTATION_SERVER_CONDITIONS_1 === (mutation.type) ) &#123; console.log( mutation ) window.localStorage.setItem(mutation.payload.key, JSON.stringify(mutation.payload.value)) &#125; if( STAGE_MUTATION_USER_OPTIONS.indexOf(mutation.type) &gt;= 0 ) &#123; window.localStorage.setItem("options", JSON.stringify(state.options)) console.log( state.options ) &#125; if( mutation.type == 'getCategoryById' ) &#123; window.localStorage.setItem("categoryInfo", JSON.stringify(state.categoryInfo)) &#125; if( mutation.type == 'getQuestionsToCategory' ) &#123; window.localStorage.setItem("qList", JSON.stringify(state.qList)) &#125; if( mutation.type == 'userSelectQids' || mutation.type == 'userSelectAnswer' || mutation.type == 'getQuestionsToCategory' ) &#123; window.localStorage.setItem("userAnswerInfos", JSON.stringify(state.userAnswerInfos)) &#125; &#125;)&#125;;export default [localStoragePlugin] 二. mutations.js 123456789101112131415161718192021222324252627282930313233343536373839404142const userAnswerInfoJSON = window.localStorage.getItem('userAnswerInfos');const userAnswerInfos = JSON.parse(userAnswerInfoJSON) || &#123;&#125;;console.log('init','options', optionsJSON, options);export const state = &#123; provinces : JSON.parse(window.localStorage.getItem('provinces')) || [], stages: JSON.parse(window.localStorage.getItem('stages')) || [], examTypes: JSON.parse(window.localStorage.getItem('examTypes')) || [], // subjects:[], options:&#123; examType: options.examType || '', area: options.area || '', preferredSubjects: options.preferredSubjects || [], subject: options.subject &gt; 0 ? options.subject : 0, preferredCategories:options.preferredCategories || [], category: options.category &gt; 0 ? options.category : 0, subCategory: options.subCategory &gt; 0 ? options.subCategory : 0, &#125;, categoryInfo:JSON.parse(window.localStorage.getItem('categoryInfo')) || [], qList: JSON.parse(window.localStorage.getItem('qList')) ||[], userAnswerInfos:&#123; qids: userAnswerInfos.qids || [], answer: userAnswerInfos.answer ||[], trueAnswer: userAnswerInfos.trueAnswer ||[] &#125;,&#125;;export const STAGE_MUTATION_USER_OPTIONS = [ 'stageExamType', 'stageArea', 'stagePhase', 'stagePreferredSubjects', 'stageSubject', 'stagePreferredCategories', 'stageCategory', 'stageSubCategory',];export const STAGE_MUTATION_SERVER_CONDITIONS_1 = "stageServerConditions1"; 三 .项目目录结构 解决思路：页面的显示很多依靠vuex的store取值的，而vuex的存储会造成页面刷新的时候值为空，所以解决方法就是每次更改store的时候再storage里面存储一份，取值之前 则先从storage里面取值，否则直接给 默认值(空对象或空数组)]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-api之gulp-task]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-task%2F</url>
    <content type="text"><![CDATA[gulp.taskgulp.task方法用来定义任务，内部使用的是Orchestrator(用于排序、执行任务和最大并发依赖关系的模块)，其语法为：1gulp.task(name[, deps], fn) name 为任务名； deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数； fn为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 当你定义一个简单的任务时，需要传入任务名字和执行函数两个属性。123gulp.task('greet', function () &#123; console.log('Hello world!');&#125;); 执行gulp greet的结果就是在控制台上打印出“Hello world”。 也可以定义一个在gulp开始运行时候默认执行的任务，并将这个任务命名为“default”： 123gulp.task('default', function () &#123; // Your default task&#125;); 当有多个任务时，需要知道怎么来控制任务的执行顺序。 可以通过任务依赖来实现。例如我想要执行one,two,three这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：12//只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task(&apos;default&apos;,[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]); 如果任务相互之间没有依赖，任务就会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。但是如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：1234567891011gulp.task('one',function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done') &#125;,5000);&#125;); //two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 上面的例子中我们执行two任务时，会先执行one任务，但不会去等待one任务中的异步操作完成后再执行two任务，而是紧接着执行two任务。所以two任务会在one任务中的异步操作完成之前就执行了。 那如果想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？ 有三种方法可以实现： 1.：在异步操作完成后执行一个回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数。123456789101112gulp.task('one',function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 exec(function()&#123; console.log('one is finish'); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;); //这时two任务会在one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is finish');&#125;); 2. ：定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。12345678910gulp.task('one',function(cb)&#123; var stream = gulp.src('client/**/*.js') .pipe(exec()) //exec()中有某些异步操作 .pipe(gulp.dest('build')); return stream;&#125;); gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 3. ：返回一个promise对象，例如1234567891011121314var Q = require('q');gulp.task('one', function() &#123; var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 1); return deferred.promise;&#125;); gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;);]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-api之gulp-watch]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-watch%2F</url>
    <content type="text"><![CDATA[gulp.watch gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为 gulp.watch(glob[, opts], tasks);glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。opts 为一个可选的配置对象，通常不需要用到。tasks 为文件变化后要执行的任务，为一个数组。 1234567gulp.task('uglify',function()&#123; //do something&#125;);gulp.task('reload',function()&#123; //do something&#125;);gulp.watch('js/**/*.js', ['uglify','reload']); gulp.watch()还有另外一种使用方式： gulp.watch(glob[, opts, cb]); glob和opts参数与第一种用法相同; cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径。 1234gulp.watch('js/**/*.js', function(event)&#123; console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;);]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-api之gulp-dest]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-dest%2F</url>
    <content type="text"><![CDATA[gulp.destgulp.dest()方法是用来写文件的，其语法为：1gulp.dest(path[,options]) path为写入文件的路径； options为一个可选的参数对象，以下为选项参数： options.cwd类型： String 默认值： process.cwd() 输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。 options.mode类型： String 默认值： 0777 八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。 123var gulp = require('gulp');gulp.src('script/jquery.js') // 获取流 .pipe(gulp.dest('dist/foo.js')); // 写放文件 下面再说说生成的文件路径与我们给gulp.dest()方法传入的路径参数之间的关系。 gulp.dest(path)生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径。例如：1234var gulp = reruire('gulp');//有通配符开始出现的那部分路径为 **/*.jsgulp.src('script/**/*.js') .pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/**/*.js 如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js用gulp.dest()把文件流写入文件后，文件流仍然可以继续使用。]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-api 之gulp.src]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-api%E4%B9%8Bgulp-src%2F</url>
    <content type="text"><![CDATA[gulp.srcgulp.src()方法是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinylfiles)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息。其语法为：1gulp.src(globs[, options]); globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。1gulp.src('script/jquery.js') // 获取script文件下的jquery.js 当有多个匹配模式时，该参数可以为一个数组;类型为String或 Array。12// 使用数组的方式来匹配多种文件`gulp.src(['js/*.js','css/*.css','*.html']) options.buffer类型： Boolean 默认值：true 如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。注意：插件可能并不会实现对 stream 的支持。 options.read类型： Boolean 默认值：true 如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。 options.base类型： String ， 设置输出路径以某个路径的某个组成部分为基础向后拼接。 如, 请想像一下在一个路径为 client/js/somedir 的目录中，有一个文件叫 somefile.js ：1234567gulp.src('client/js/**/*.js') // 匹配 'client/js/somedir/somefile.js' 现在 `base` 的值为 `client/js/` .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/somedir/somefile.js' 将`client/js/`替换为build gulp.src('client/js/**/*.js', &#123; base: 'client' &#125;) // base 的值为 'client' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/js/somedir/somefile.js' 将`client`替换为build]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp 入门文档]]></title>
    <url>%2F2017%2F08%2F28%2Fgulp-%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[新建 gulpfile.js gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript、coffee、sass、less、html/image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 npm init新建gulpfile.js文件写入 gulp任务 123456789101112131415161718var gulp = require('gulp'), less = require('gulp-less'), minifyCSS = require('gulp-minify-css');gulp.task('testLess', function () &#123; gulp.src('src/less/index.less') .pipe(less()) .pipe(gulp.dest('dist/css'));&#125;);gulp.task('css', function () &#123; gulp.src('dist/css/*.css') .pipe(minifyCSS()) .pipe(gulp.dest('dist/css'))&#125;)gulp.task('default',['css']); 命令行 gulp 或者gulp css/testLess gulp的使用流程一般是：首先通过gulp.src()方法获取到想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中。例如： *123var gulp = require('gulp');gulp.src('script/jquery.js') // 获取流的api .pipe(gulp.dest('dist/foo.js')); // 写放文件的api]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于javascrip中sort函数的使用]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%85%B3%E4%BA%8Ejavascrip%E4%B8%ADsort%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[需求有个这样的东西，后台接口各个城市的数据，前端根据数据按照首字母进行分类，排序，进行渲染。在W3CSchool中看到，这个函数的一些说明。如下图 原始数据格式如下：12345[ &#123;"Name": "江苏省", "cityList": [...],"Header": "jiangsusheng"&#125;, &#123;"Name": "江西省", "cityList": [...],"Header": "jiangxisheng"&#125;, &#123;"Name": "辽宁省","cityList": [...],"Header": "liaoningsheng"&#125;] 我们只需要将数据格式更换为1234567891011 [ &#123; "name":"A", "city":[ &#123;"Name": "辽宁省","cityList": [...],"Header": "liaoningsheng"&#125;] &#125;, &#123; "name":"J", "city":[ &#123;"Name": "江苏省", "cityList": [...],"Header": "jiangsusheng"&#125;, &#123;"Name": "江西省", "cityList": [...],"Header": "jiangxisheng"&#125; ] &#125;,] 第一步 将数组首字母相同的合并123456789101112131415161718192021function merge(arr) &#123; var res = []; var json = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if (!json[arr[i].name]) &#123; var sJson=&#123;&#125;; sJson.name=arr[i].name; sJson.list=arr[i].list; res.push(sJson); json[arr[i].name] = 1; &#125;else&#123; for(var k=0; k&lt;res.length; k++)&#123; if(arr[i].name==res[k].name)&#123; res[k].list.push(arr[i].list[0]); break; &#125; &#125; &#125; &#125; return res;&#125; 第二步 实现数组按照某个属性排序1234567891011121314151617function rank (prop)&#123; return function (obj1, obj2) &#123; var val1 = obj1[prop]; var val2 = obj2[prop]; if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123; val1 = Number(val1); val2 = Number(val2); &#125; if (val1 &gt; val2) &#123; //升序排列 return 1; &#125; else if (val1 &lt; val2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;;&#125; eg:12345[ &#123;name:'gpp',age:0&#125;, &#123;name:'aop',age:18&#125;, &#123;name:'yjj',age:8&#125; ] 效果123456arr.sort(rank('name'))[ &#123;name:'aop',age:0&#125;, &#123;name:'gpp',age:18&#125;, name:'yjj',age:8&#125; ] 至此，完结.]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 的 Promise 对象]]></title>
    <url>%2F2017%2F08%2F10%2FES6-%E7%9A%84-Promise-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[目录一段使用了promise的基本语句代码123456789101112131415function helloWorld (ready) &#123; return new Promise(function (resolve, reject) &#123; if (ready) &#123; resolve("Hello World!"); &#125; else &#123; reject("Good bye!"); &#125; &#125;);&#125;helloWorld(true).then(function (message) &#123; alert(message);&#125;, function (error) &#123; alert(error);&#125;); 上面的代码实现的功能非常简单~~，helloWord函数接受一个参数，如果为 true 就打印 “Hello World!”，如果为 false 就打印错误的信息。helloWord 函数返回的是一个 ==Promise== 对象。 resolve 和 reject在 Promise 对象当中有两个重要方法————resolve 和 reject。 resolve 方法可以使 Promise对象的状态改变成成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。 reject 方法则是将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。 then 和 catchthen1234567891011121314151617181920212223function printHello(ready)&#123; return new Promise(function(resolve,reject)&#123; if(ready)&#123; resolve("hello") &#125;else&#123; reject("bad") &#125; &#125;)&#125;function printWorld()&#123; alert('world')&#125;function print1()&#123; alert('!')&#125;printHello(true).then(function(message)&#123; alert(message)&#125;).then(printWorld).then(print1) then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象。另外，在 then onFulfilled的函数当中的返回值，可以作为后续操作的参数，因此上面的例子也可以写成 123456789101112131415161718192021function printHello(ready)&#123; return new Promise(function(resolve,reject)&#123; if(ready)&#123; resolve("hello") &#125;else&#123; reject("err") &#125; &#125;)&#125;printHello(true).then(function(message)&#123; return message&#125;).then(function(message)&#123; return message+'world'&#125;).then(function(message)&#123; return message + '!'&#125;).then(function(message)&#123; alert(message)&#125;).catch(function(err)&#123; alert(err)&#125;); catch catch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected函数的一个简单的写法，也就是说可以写成 then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch的写法比一般的写法更加清晰明确。 Promise.all 和 Promise.race Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为resolve 时，该方法才会返回。 123456789101112131415var p1 = new Promise(function (resolve) &#123; setTimeout(function () &#123; resolve("Hello"); &#125;, 3000);&#125;);var p2 = new Promise(function (resolve) &#123; setTimeout(function () &#123; resolve("World"); &#125;, 1000);&#125;);Promise.all([p1, p2]).then(function (result) &#123; console.log(result); // ["Hello", "World"]&#125;); 上面的例子模拟了传输两个数据需要不同的时长，虽然 p2 的速度比 p1 要快，但是 Promise.all 方法会按照数组里面的顺序将结果返回。 日常开发中经常会遇到这样的需求，在不同的接口请求数据然后拼合成自己所需的数据，通常这些接口之间没有关联（例如不需要前一个接口的数据作为后一个接口的参数），这个时候 Promise.all 方法就可以派上用场了。还有一个和 Promise.all 相类似的方法 Promise.race，它同样接收一个数组，不同的是只要该数组中的 Promise 对象的状态发生变化（无论是 resolve 还是 reject）该方法都会返回。 参考JavaScript Promise迷你书（中文版）]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建的blog的流程]]></title>
    <url>%2F2017%2F08%2F08%2F%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%9A%84blog%E7%9A%84%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[按照流程进行如下初始环境配置 本地环境搭建1$ npm install hexo-cli -g 1$ hexo init 1$ npm install 1$ hexo g 1$ hexo s 运行localhost:4000端口即可访问 hexo基本命令： hexo g #完整命令为hexo generate，用于生成静态文件 hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览 hexo d #完整命令为hexo deploy，用于将本地文件发布到github上 hexo n #完整命令为hexo new，用于新建一篇文章 hexo clean 清除缓存 更改默认主题配置下载next (配置了大众化的next) $ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改根目录配置文件theme: next 发布文章每次发布执行以下3步即可 hexo clean hexo generate hexo deploy 新建文章hexo new “xxx”在source目录下找到新建页面修改即可。 #删除文章eg:(helloworld)&nbsp;&nbsp;&nbsp;&nbsp;先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。&nbsp;&nbsp;&nbsp;&nbsp;具体来说，以最开始默认形成的helloworld.md这篇文章为例。首先进入到source / _post 文件夹中，&nbsp;&nbsp;&nbsp;&nbsp;找到helloworld.md文件，在本地直接执行删除。然后依次执行hexo g，hexo d，这就是如何删除文章的方法。 同步远程仓库修改配置修改根目录配置文件_config.yml&nbsp;&nbsp;&nbsp;&nbsp; type: git&nbsp;&nbsp;&nbsp;&nbsp; repository: https://github.com/username/username.github.io.git&nbsp;&nbsp;&nbsp;&nbsp; branch: master hexo deploy 发布* ERROR: &nbsp;&nbsp;&nbsp;Deployer not found : github&nbsp;&nbsp;&nbsp;&nbsp; npm install hexo-deployer-git –save]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
